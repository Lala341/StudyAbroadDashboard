<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>University Rankings Scatter Plot with Country Grid</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
  <div>
    <label for="topNSelector">Top N:</label>
    <select id="topNSelector">
      <option value="10" selected>10</option>
      <option value="50" >50</option>
      <option value="100">100</option>
      <option value="200">200</option>
      <option value="300">300</option>
      <option value="400">400</option>
      <option value="500">500</option>
    </select>
    <button onclick="updateChart()">Filter</button>
  </div>
  <div class="tooltip" id="tooltip"></div>

  <div id="chart"></div>

  <style>
    .tooltip {
      position: absolute;
      padding: 10px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
  </style>

  <script>
    // Define dimensions
    const width = 1000;
    const height = 900;
    const gridPadding = 30;  // Padding between grid cells

    // Append SVG
    const svg = d3.select("#chart")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    var data = [];

    // Load CSV data
    d3.csv("your_data.csv").then(function(csvData) {
      data = csvData;
      const topN = +document.getElementById("topNSelector").value; // Get the selected top N value
      data.sort((a, b) => a.world_rank - b.world_rank);

      // Take the top N rows based on the sorted order
      const filteredData = data.slice(0, topN);

      drawChart(filteredData); // Call drawChart after loading the data
    });

    function drawChart(data) {
      // Define scales
      const xScale = d3.scaleLinear()
        .domain([0, 100])  // Assuming the x-axis is a percentage (0-100)
        .range([0, width]);

      const yScale = d3.scaleLinear()
        .domain([0, 100])  // Assuming the y-axis is a percentage (0-100)
        .range([height, 0]);

      // Group data by country
      const groupedData = d3.group(data, d => d.country);

      // Create a grid layout for countries
      const countries = Array.from(groupedData.keys());
      const gridCols = 5;  // Number of columns in the grid
      const gridRows = Math.ceil(countries.length / gridCols);  // Calculate the number of rows

      // Calculate cell dimensions
      const cellWidth = (width - (gridCols - 1) * gridPadding) / gridCols;
      const cellHeight = (height - (gridRows - 1) * gridPadding) / gridRows;

      const group = svg.append("g")
        .attr("transform", "translate(" + (100) + "," + (0) + ")")

      const numpitch = 40;
      const tooltip = d3.select("#tooltip"); // Select the existing tooltip

      // Create array of objects with normalizedQuery and avgCount
      const datosa = Array.from(groupedData).map(([normalizedQuery, universities]) => ({
        normalizedQuery,
        universities : universities, 
        avgCount: universities.length
      }));
      const datos = datosa.sort((a, b) => b.avgCount - a.avgCount);

      for (let i = 0; i < datos.length; i++) {
        const row = Math.floor(i / gridCols);
        const col = i % gridCols;

        const dots = group.append("g")
          .attr("transform", function () {
            return "translate(" + (numpitch + 120 * col) + "," + (cellHeight * row) + ")rotate(0)";
          });

        const balls = datos[i].avgCount;
        const brack = 10;
        const filas = balls / brack;
        const enteros = Math.ceil(balls / brack) - 1;
        const resto = (filas - enteros) * 10;

        if (resto >= 0) {
          for (let lev = 0; lev < enteros; lev++) {
            for (let k = 1; k <= brack; k++) {
              const universityData = datos[i].universities[brack * lev + k - 1];
            dots.append("circle")
              .attr("cx", k * 10)
              .attr("cy", 300 - lev * 10)
              .attr("r", 4)
              .attr("opacity", 1)
              .attr("fill", d3.rgb(10, 255 - i * 30, 255 - i * 20))
              .on("mouseover", function () {
                const tooltipContent = `
                  University: ${universityData.university_name}<br>
                  Country: ${universityData.country}<br>
                  Teaching: ${universityData.teaching}<br>
                  International: ${universityData.international}<br>
                `;
                tooltip.html(tooltipContent)
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 10) + "px")
                  .style("opacity", 1);
              })
              .on("mouseout", function () {
                tooltip.style("opacity", 0);
              });
            }
          }

          for (let r = 1; r <= resto; r++) {
            dots.append("circle")
              .attr("cx", r * 10)
              .attr("cy", 300 - (enteros) * 10)
              .attr("r", 4)
              .attr("opacity", 1)
              .attr("fill", d3.rgb(10, 255 - i * 30, 255 - i * 20))
              .on("mouseover", function () {
                const universityData = datos[i].universities[brack * enteros + r - 1];
                
                const tooltipContent = `
                  University: ${universityData.university_name}<br>
                  Country: ${universityData.country}<br>
                  Teaching: ${universityData.teaching}<br>
                  International: ${universityData.international}<br>
                `;
                tooltip.html(tooltipContent)
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 10) + "px")
                  .style("opacity", 1);
              })
              .on("mouseout", function () {
                tooltip.style("opacity", 0);
              });
          }
        }

        dots.append("text")
        .attr("x", 5)
        .attr("y", 320)
        .text(function (d) { return datos[i].avgCount; })
        .attr("font-family", "Gill Sans, sans-serif")
        .attr("font-size", 12)
        .attr("text-anchor", "start")
        .style("fill", "black");

        const text = dots.append("text")
          .attr("x", 5)
          .attr("y", 335)
          .attr("font-family", "Gill Sans, Century Gothic, sans-serif")
          .attr("font-size", 12)
          .attr("opacity", 1)
          .style("fill", "black");

        const nameWords = datos[i].normalizedQuery.toUpperCase().split(/\s+/);
        const lineHeight = 1.1;
        const dy = 12;

        text.selectAll("tspan")
          .data(nameWords)
          .enter().append("tspan")
          .attr("x", 5)
          .attr("dy", (d, i) => i ? lineHeight + dy : 0)
          .text(d => d);
      }

      // Add axes
      const xAxis = d3.axisBottom(xScale);
      const yAxis = d3.axisLeft(yScale);

      svg.append("g")
        .attr("transform", `translate(0, ${height})`)
        .call(xAxis);

      svg.append("g")
        .call(yAxis);
    }

    function updateChart() {
      const topN = +document.getElementById("topNSelector").value;
      data.sort((a, b) => a.world_rank - b.world_rank);

      const filteredData = data.slice(0, topN);

      svg.selectAll("*").remove();

      drawChart(filteredData);
    }
  </script>
</body>
</html>
